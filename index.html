<html>
<head>
  <script src="https://code.jquery.com/jquery.js"></script>

  <!-- Note: Probably not the way 'bower' dependencies are supposed to be used, but works for us.
  -->
  <script src="bower_components/svg.js/dist/svg.js" type="text/javascript"></script>
  <script src="bower_components/svg.draggable.js/dist/svg.draggable.js" type="text/javascript"></script>
  <!--
  <script src="bower_components/assert/dist/assert.js"></script>
  -->
    
  <script src="node_modules/rx-lite/rx.lite.min.js"></script>
  <script src="js/svg.track.js"></script>
  
  <style>
    rect.main { 
      fill: blue;
      fill-opacity: 0.8;
    }
    rect.corner { 
      fill: yellow;
      fill-opacity: 0.5;
    }
    rect { 
      fill: purple;
    }
  </style>
</head>

<!-- Make a rectangle with corners as separate rectangles, so that everything
- follows each other (i.e. corners resize the big rect, panning bit rect moves
- also the corners).
-->
<body>
  <div id="cradle">
  </div>
  
  <script>
    var W= 100;
    var CORNER_SIZE = 20;
    var CORNER_OFFSET = 5;
    
    var svg = SVG("cradle");   // fills the cradle fully

    var g = svg.group();

    /***
    // Bindable values, somehow
    //
    var top_ = 0;   //new Observable(0, function(dy) { ... drag the whole group up/down 'dy' ... });
    var right = new SVG.Observable(W);
    var bottom = new SVG.Observable(W);
    var left = 0;   //new Observable(0, function(dx) { ... drag the whole group left/right 'dx' ... });
    
    console.log( right instanceof SVG.Observable );
    console.log( left instanceof SVG.Observable );
    
    // Do four corners (note: the corner's (0,0) will be where the main box's particular corner tracks them).
    //
    // - use 'move()' to change the 'x,y'
    // - use 'translate()' to position the origin
    //
    for( var i=0; i<4; i++ ) {    // ne,se,sw,nw
      var dx = (i<2) ? right : left;
      var dy = (i==1 || i==2) ? bottom : top_;

      var tx = (i<2) ? -(CORNER_SIZE-CORNER_OFFSET) : -CORNER_OFFSET;
      var ty = (i==1 || i==2) ? -(CORNER_SIZE-CORNER_OFFSET) : -CORNER_OFFSET;
    
      var corner = g.rect(CORNER_SIZE,CORNER_SIZE)
                    .translate( tx,ty )
                    .move( dx,dy )        // '.x()' and '.y()' are updated so that this will set up a dynamic relationship
                    .addClass("corner")
                    .draggable();         // tbd: make 'draggable' able to inform changes to the Observables

      corner.on("dragstart.namespace", function (ev) {
        console.log("Drag start", ev);
        
      }).on("dragmove.namespace", function (ev) {
        console.log("Drag move", ev);

      }).on("dragend.namespace", function (ev) {
        console.log("Drag end", ev);

      });
    }
    ***/

    var xObs = new SVG.Observable(),
      yObs = new SVG.Observable(),
      widthObs = new SVG.Observable(),
      heightObs = new SVG.Observable();

    // Main rect, bound to the corners dynamically (tbd: push below them)
    //
    g.rect(W,W)
     .addClass("main")
     .draggable()
     .track( xObs, yObs, widthObs, heightObs );
    
    g.move(50,50);
    g.x(100);
        
    // Should output x -> 50, y -> 50 at load time, then follow any drag movements.
    //
    xObs.subscribe( function (v) { console.log("x -> "+ v); } );
    yObs.subscribe( function (v) { console.log("y -> "+ v); } );
    widthObs.subscribe( function (v) { console.log("width -> "+ v); } );
    heightObs.subscribe( function (v) { console.log("height -> "+ v); } );

    g.x(120);
    g.width(200);

  </script>
  
</body>
</html>
